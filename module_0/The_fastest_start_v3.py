
# coding: utf-8

import numpy as np

def game_core_v5(number):
    
    # Функция принимает загаданное число и возвращает число попыток угадывания (в среднем за 5.8 попыток)
    # алгоритм половинного деления (разновидность метода последовательных приближений) доработан, 
    # вместо сдвига границ множежства (в предыдущей версии) здесь расчитывается уменьшающаяся корректировка предсказания
    
    count = 1          # счетчик попыток
    predict = 50       # начальное предсказание (первая попытка, счетчик равен 1)
    adjustment = 25    # коррекутировка
    
    while number != predict:
        count+=1
        
        if number > predict:      # если предсказание меньше добавляем корректировку
            predict += adjustment
            
        elif number < predict:    # если предсказание больше вычитаем корректировку
            predict -= adjustment
            
        if adjustment < 1:                    # не позволяем корректировке стать нулевой
                            adjustment = 1
        else:
                            adjustment = int(np.around(adjustment/2)) # уменьшаем в 2 раза размер корректирови
                                                                      # в следующей итерации
        
    return(count) # выход из цикла, если угадали
        
def score_game(game_core):
    
    '''Запускаем игру 1000 раз, чтобы узнать, как быстро игра угадывает число'''
    count_ls = []
    np.random.seed(1)  # фиксируем RANDOM SEED, чтобы ваш эксперимент был воспроизводим!
    random_array = np.random.randint(1,101, size=(1000)) # заполняем 1000 случайных чисел
    
    for number in random_array:
        count_ls.append(game_core(number))    # для каждого случайного числа записываем каличество попыток
        
      
    score = np.mean(count_ls)                 # считаем среднее каличество попыток для 1000 чисел  
        
    print(f"Ваш алгоритм угадывает число в среднем за {score} попыток")
    
    return(score)

score_game(game_core_v5)


